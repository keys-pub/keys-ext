// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package service

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion6

// KeysClient is the client API for Keys service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type KeysClient interface {
	KeyGenerate(ctx context.Context, in *KeyGenerateRequest, opts ...grpc.CallOption) (*KeyGenerateResponse, error)
	Keys(ctx context.Context, in *KeysRequest, opts ...grpc.CallOption) (*KeysResponse, error)
	Key(ctx context.Context, in *KeyRequest, opts ...grpc.CallOption) (*KeyResponse, error)
	KeyImport(ctx context.Context, in *KeyImportRequest, opts ...grpc.CallOption) (*KeyImportResponse, error)
	KeyExport(ctx context.Context, in *KeyExportRequest, opts ...grpc.CallOption) (*KeyExportResponse, error)
	KeyRemove(ctx context.Context, in *KeyRemoveRequest, opts ...grpc.CallOption) (*KeyRemoveResponse, error)
	Sign(ctx context.Context, in *SignRequest, opts ...grpc.CallOption) (*SignResponse, error)
	SignFile(ctx context.Context, opts ...grpc.CallOption) (Keys_SignFileClient, error)
	SignStream(ctx context.Context, opts ...grpc.CallOption) (Keys_SignStreamClient, error)
	Verify(ctx context.Context, in *VerifyRequest, opts ...grpc.CallOption) (*VerifyResponse, error)
	VerifyFile(ctx context.Context, opts ...grpc.CallOption) (Keys_VerifyFileClient, error)
	VerifyStream(ctx context.Context, opts ...grpc.CallOption) (Keys_VerifyStreamClient, error)
	VerifyDetached(ctx context.Context, in *VerifyDetachedRequest, opts ...grpc.CallOption) (*VerifyDetachedResponse, error)
	VerifyDetachedFile(ctx context.Context, opts ...grpc.CallOption) (Keys_VerifyDetachedFileClient, error)
	VerifyDetachedStream(ctx context.Context, opts ...grpc.CallOption) (Keys_VerifyDetachedStreamClient, error)
	Encrypt(ctx context.Context, in *EncryptRequest, opts ...grpc.CallOption) (*EncryptResponse, error)
	EncryptStream(ctx context.Context, opts ...grpc.CallOption) (Keys_EncryptStreamClient, error)
	EncryptFile(ctx context.Context, opts ...grpc.CallOption) (Keys_EncryptFileClient, error)
	Decrypt(ctx context.Context, in *DecryptRequest, opts ...grpc.CallOption) (*DecryptResponse, error)
	DecryptStream(ctx context.Context, opts ...grpc.CallOption) (Keys_DecryptStreamClient, error)
	DecryptFile(ctx context.Context, opts ...grpc.CallOption) (Keys_DecryptFileClient, error)
	Sigchain(ctx context.Context, in *SigchainRequest, opts ...grpc.CallOption) (*SigchainResponse, error)
	Statement(ctx context.Context, in *StatementRequest, opts ...grpc.CallOption) (*StatementResponse, error)
	StatementCreate(ctx context.Context, in *StatementCreateRequest, opts ...grpc.CallOption) (*StatementCreateResponse, error)
	StatementRevoke(ctx context.Context, in *StatementRevokeRequest, opts ...grpc.CallOption) (*StatementRevokeResponse, error)
	User(ctx context.Context, in *UserRequest, opts ...grpc.CallOption) (*UserResponse, error)
	UserSearch(ctx context.Context, in *UserSearchRequest, opts ...grpc.CallOption) (*UserSearchResponse, error)
	UserService(ctx context.Context, in *UserServiceRequest, opts ...grpc.CallOption) (*UserServiceResponse, error)
	UserSign(ctx context.Context, in *UserSignRequest, opts ...grpc.CallOption) (*UserSignResponse, error)
	UserAdd(ctx context.Context, in *UserAddRequest, opts ...grpc.CallOption) (*UserAddResponse, error)
	Search(ctx context.Context, in *SearchRequest, opts ...grpc.CallOption) (*SearchResponse, error)
	Secret(ctx context.Context, in *SecretRequest, opts ...grpc.CallOption) (*SecretResponse, error)
	SecretSave(ctx context.Context, in *SecretSaveRequest, opts ...grpc.CallOption) (*SecretSaveResponse, error)
	SecretRemove(ctx context.Context, in *SecretRemoveRequest, opts ...grpc.CallOption) (*SecretRemoveResponse, error)
	Secrets(ctx context.Context, in *SecretsRequest, opts ...grpc.CallOption) (*SecretsResponse, error)
	Pull(ctx context.Context, in *PullRequest, opts ...grpc.CallOption) (*PullResponse, error)
	Push(ctx context.Context, in *PushRequest, opts ...grpc.CallOption) (*PushResponse, error)
	Wormhole(ctx context.Context, opts ...grpc.CallOption) (Keys_WormholeClient, error)
	// These requests do not need auth.
	// BEGIN NO AUTH
	AuthSetup(ctx context.Context, in *AuthSetupRequest, opts ...grpc.CallOption) (*AuthSetupResponse, error)
	AuthVault(ctx context.Context, in *AuthVaultRequest, opts ...grpc.CallOption) (*AuthVaultResponse, error)
	AuthUnlock(ctx context.Context, in *AuthUnlockRequest, opts ...grpc.CallOption) (*AuthUnlockResponse, error)
	AuthLock(ctx context.Context, in *AuthLockRequest, opts ...grpc.CallOption) (*AuthLockResponse, error)
	AuthReset(ctx context.Context, in *AuthResetRequest, opts ...grpc.CallOption) (*AuthResetResponse, error)
	AuthRecover(ctx context.Context, in *AuthRecoverRequest, opts ...grpc.CallOption) (*AuthRecoverResponse, error)
	RuntimeStatus(ctx context.Context, in *RuntimeStatusRequest, opts ...grpc.CallOption) (*RuntimeStatusResponse, error)
	Rand(ctx context.Context, in *RandRequest, opts ...grpc.CallOption) (*RandResponse, error)
	RandPassword(ctx context.Context, in *RandPasswordRequest, opts ...grpc.CallOption) (*RandPasswordResponse, error)
	// Auth (edit)
	AuthProvision(ctx context.Context, in *AuthProvisionRequest, opts ...grpc.CallOption) (*AuthProvisionResponse, error)
	AuthDeprovision(ctx context.Context, in *AuthDeprovisionRequest, opts ...grpc.CallOption) (*AuthDeprovisionResponse, error)
	AuthProvisions(ctx context.Context, in *AuthProvisionsRequest, opts ...grpc.CallOption) (*AuthProvisionsResponse, error)
	AuthPasswordChange(ctx context.Context, in *AuthPasswordChangeRequest, opts ...grpc.CallOption) (*AuthPasswordChangeResponse, error)
	// Vault
	VaultAuth(ctx context.Context, in *VaultAuthRequest, opts ...grpc.CallOption) (*VaultAuthResponse, error)
	VaultSync(ctx context.Context, in *VaultSyncRequest, opts ...grpc.CallOption) (*VaultSyncResponse, error)
	VaultUnsync(ctx context.Context, in *VaultUnsyncRequest, opts ...grpc.CallOption) (*VaultUnsyncResponse, error)
	VaultStatus(ctx context.Context, in *VaultStatusRequest, opts ...grpc.CallOption) (*VaultStatusResponse, error)
	VaultUpdate(ctx context.Context, in *VaultUpdateRequest, opts ...grpc.CallOption) (*VaultUpdateResponse, error)
	// DB
	Collections(ctx context.Context, in *CollectionsRequest, opts ...grpc.CallOption) (*CollectionsResponse, error)
	Documents(ctx context.Context, in *DocumentsRequest, opts ...grpc.CallOption) (*DocumentsResponse, error)
	DocumentDelete(ctx context.Context, in *DocumentDeleteRequest, opts ...grpc.CallOption) (*DocumentDeleteResponse, error)
	// Config
	ConfigGet(ctx context.Context, in *ConfigGetRequest, opts ...grpc.CallOption) (*ConfigGetResponse, error)
	ConfigSet(ctx context.Context, in *ConfigSetRequest, opts ...grpc.CallOption) (*ConfigSetResponse, error)
	// Admin
	AdminSignURL(ctx context.Context, in *AdminSignURLRequest, opts ...grpc.CallOption) (*AdminSignURLResponse, error)
	AdminCheck(ctx context.Context, in *AdminCheckRequest, opts ...grpc.CallOption) (*AdminCheckResponse, error)
	// Channels
	Channels(ctx context.Context, in *ChannelsRequest, opts ...grpc.CallOption) (*ChannelsResponse, error)
	ChannelCreate(ctx context.Context, in *ChannelCreateRequest, opts ...grpc.CallOption) (*ChannelCreateResponse, error)
	ChannelUsers(ctx context.Context, in *ChannelUsersRequest, opts ...grpc.CallOption) (*ChannelUsersResponse, error)
	ChannelInvitesCreate(ctx context.Context, in *ChannelInvitesCreateRequest, opts ...grpc.CallOption) (*ChannelInvitesCreateResponse, error)
	ChannelUninvite(ctx context.Context, in *ChannelUninviteRequest, opts ...grpc.CallOption) (*ChannelUninviteResponse, error)
	ChannelInvites(ctx context.Context, in *ChannelInvitesRequest, opts ...grpc.CallOption) (*ChannelInvitesResponse, error)
	ChannelUserInvites(ctx context.Context, in *ChannelUserInvitesRequest, opts ...grpc.CallOption) (*ChannelUserInvitesResponse, error)
	ChannelJoin(ctx context.Context, in *ChannelJoinRequest, opts ...grpc.CallOption) (*ChannelJoinResponse, error)
	ChannelLeave(ctx context.Context, in *ChannelLeaveRequest, opts ...grpc.CallOption) (*ChannelLeaveResponse, error)
	// Messages
	MessagePrepare(ctx context.Context, in *MessagePrepareRequest, opts ...grpc.CallOption) (*MessagePrepareResponse, error)
	MessageCreate(ctx context.Context, in *MessageCreateRequest, opts ...grpc.CallOption) (*MessageCreateResponse, error)
	Messages(ctx context.Context, in *MessagesRequest, opts ...grpc.CallOption) (*MessagesResponse, error)
	// Relay
	Relay(ctx context.Context, in *RelayRequest, opts ...grpc.CallOption) (Keys_RelayClient, error)
}

type keysClient struct {
	cc grpc.ClientConnInterface
}

func NewKeysClient(cc grpc.ClientConnInterface) KeysClient {
	return &keysClient{cc}
}

func (c *keysClient) KeyGenerate(ctx context.Context, in *KeyGenerateRequest, opts ...grpc.CallOption) (*KeyGenerateResponse, error) {
	out := new(KeyGenerateResponse)
	err := c.cc.Invoke(ctx, "/keys.Keys/KeyGenerate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keysClient) Keys(ctx context.Context, in *KeysRequest, opts ...grpc.CallOption) (*KeysResponse, error) {
	out := new(KeysResponse)
	err := c.cc.Invoke(ctx, "/keys.Keys/Keys", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keysClient) Key(ctx context.Context, in *KeyRequest, opts ...grpc.CallOption) (*KeyResponse, error) {
	out := new(KeyResponse)
	err := c.cc.Invoke(ctx, "/keys.Keys/Key", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keysClient) KeyImport(ctx context.Context, in *KeyImportRequest, opts ...grpc.CallOption) (*KeyImportResponse, error) {
	out := new(KeyImportResponse)
	err := c.cc.Invoke(ctx, "/keys.Keys/KeyImport", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keysClient) KeyExport(ctx context.Context, in *KeyExportRequest, opts ...grpc.CallOption) (*KeyExportResponse, error) {
	out := new(KeyExportResponse)
	err := c.cc.Invoke(ctx, "/keys.Keys/KeyExport", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keysClient) KeyRemove(ctx context.Context, in *KeyRemoveRequest, opts ...grpc.CallOption) (*KeyRemoveResponse, error) {
	out := new(KeyRemoveResponse)
	err := c.cc.Invoke(ctx, "/keys.Keys/KeyRemove", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keysClient) Sign(ctx context.Context, in *SignRequest, opts ...grpc.CallOption) (*SignResponse, error) {
	out := new(SignResponse)
	err := c.cc.Invoke(ctx, "/keys.Keys/Sign", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keysClient) SignFile(ctx context.Context, opts ...grpc.CallOption) (Keys_SignFileClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Keys_serviceDesc.Streams[0], "/keys.Keys/SignFile", opts...)
	if err != nil {
		return nil, err
	}
	x := &keysSignFileClient{stream}
	return x, nil
}

type Keys_SignFileClient interface {
	Send(*SignFileInput) error
	Recv() (*SignFileOutput, error)
	grpc.ClientStream
}

type keysSignFileClient struct {
	grpc.ClientStream
}

func (x *keysSignFileClient) Send(m *SignFileInput) error {
	return x.ClientStream.SendMsg(m)
}

func (x *keysSignFileClient) Recv() (*SignFileOutput, error) {
	m := new(SignFileOutput)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *keysClient) SignStream(ctx context.Context, opts ...grpc.CallOption) (Keys_SignStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Keys_serviceDesc.Streams[1], "/keys.Keys/SignStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &keysSignStreamClient{stream}
	return x, nil
}

type Keys_SignStreamClient interface {
	Send(*SignInput) error
	Recv() (*SignOutput, error)
	grpc.ClientStream
}

type keysSignStreamClient struct {
	grpc.ClientStream
}

func (x *keysSignStreamClient) Send(m *SignInput) error {
	return x.ClientStream.SendMsg(m)
}

func (x *keysSignStreamClient) Recv() (*SignOutput, error) {
	m := new(SignOutput)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *keysClient) Verify(ctx context.Context, in *VerifyRequest, opts ...grpc.CallOption) (*VerifyResponse, error) {
	out := new(VerifyResponse)
	err := c.cc.Invoke(ctx, "/keys.Keys/Verify", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keysClient) VerifyFile(ctx context.Context, opts ...grpc.CallOption) (Keys_VerifyFileClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Keys_serviceDesc.Streams[2], "/keys.Keys/VerifyFile", opts...)
	if err != nil {
		return nil, err
	}
	x := &keysVerifyFileClient{stream}
	return x, nil
}

type Keys_VerifyFileClient interface {
	Send(*VerifyFileInput) error
	Recv() (*VerifyFileOutput, error)
	grpc.ClientStream
}

type keysVerifyFileClient struct {
	grpc.ClientStream
}

func (x *keysVerifyFileClient) Send(m *VerifyFileInput) error {
	return x.ClientStream.SendMsg(m)
}

func (x *keysVerifyFileClient) Recv() (*VerifyFileOutput, error) {
	m := new(VerifyFileOutput)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *keysClient) VerifyStream(ctx context.Context, opts ...grpc.CallOption) (Keys_VerifyStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Keys_serviceDesc.Streams[3], "/keys.Keys/VerifyStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &keysVerifyStreamClient{stream}
	return x, nil
}

type Keys_VerifyStreamClient interface {
	Send(*VerifyInput) error
	Recv() (*VerifyOutput, error)
	grpc.ClientStream
}

type keysVerifyStreamClient struct {
	grpc.ClientStream
}

func (x *keysVerifyStreamClient) Send(m *VerifyInput) error {
	return x.ClientStream.SendMsg(m)
}

func (x *keysVerifyStreamClient) Recv() (*VerifyOutput, error) {
	m := new(VerifyOutput)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *keysClient) VerifyDetached(ctx context.Context, in *VerifyDetachedRequest, opts ...grpc.CallOption) (*VerifyDetachedResponse, error) {
	out := new(VerifyDetachedResponse)
	err := c.cc.Invoke(ctx, "/keys.Keys/VerifyDetached", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keysClient) VerifyDetachedFile(ctx context.Context, opts ...grpc.CallOption) (Keys_VerifyDetachedFileClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Keys_serviceDesc.Streams[4], "/keys.Keys/VerifyDetachedFile", opts...)
	if err != nil {
		return nil, err
	}
	x := &keysVerifyDetachedFileClient{stream}
	return x, nil
}

type Keys_VerifyDetachedFileClient interface {
	Send(*VerifyDetachedFileInput) error
	CloseAndRecv() (*VerifyDetachedResponse, error)
	grpc.ClientStream
}

type keysVerifyDetachedFileClient struct {
	grpc.ClientStream
}

func (x *keysVerifyDetachedFileClient) Send(m *VerifyDetachedFileInput) error {
	return x.ClientStream.SendMsg(m)
}

func (x *keysVerifyDetachedFileClient) CloseAndRecv() (*VerifyDetachedResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(VerifyDetachedResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *keysClient) VerifyDetachedStream(ctx context.Context, opts ...grpc.CallOption) (Keys_VerifyDetachedStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Keys_serviceDesc.Streams[5], "/keys.Keys/VerifyDetachedStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &keysVerifyDetachedStreamClient{stream}
	return x, nil
}

type Keys_VerifyDetachedStreamClient interface {
	Send(*VerifyDetachedInput) error
	CloseAndRecv() (*VerifyDetachedResponse, error)
	grpc.ClientStream
}

type keysVerifyDetachedStreamClient struct {
	grpc.ClientStream
}

func (x *keysVerifyDetachedStreamClient) Send(m *VerifyDetachedInput) error {
	return x.ClientStream.SendMsg(m)
}

func (x *keysVerifyDetachedStreamClient) CloseAndRecv() (*VerifyDetachedResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(VerifyDetachedResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *keysClient) Encrypt(ctx context.Context, in *EncryptRequest, opts ...grpc.CallOption) (*EncryptResponse, error) {
	out := new(EncryptResponse)
	err := c.cc.Invoke(ctx, "/keys.Keys/Encrypt", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keysClient) EncryptStream(ctx context.Context, opts ...grpc.CallOption) (Keys_EncryptStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Keys_serviceDesc.Streams[6], "/keys.Keys/EncryptStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &keysEncryptStreamClient{stream}
	return x, nil
}

type Keys_EncryptStreamClient interface {
	Send(*EncryptInput) error
	Recv() (*EncryptOutput, error)
	grpc.ClientStream
}

type keysEncryptStreamClient struct {
	grpc.ClientStream
}

func (x *keysEncryptStreamClient) Send(m *EncryptInput) error {
	return x.ClientStream.SendMsg(m)
}

func (x *keysEncryptStreamClient) Recv() (*EncryptOutput, error) {
	m := new(EncryptOutput)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *keysClient) EncryptFile(ctx context.Context, opts ...grpc.CallOption) (Keys_EncryptFileClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Keys_serviceDesc.Streams[7], "/keys.Keys/EncryptFile", opts...)
	if err != nil {
		return nil, err
	}
	x := &keysEncryptFileClient{stream}
	return x, nil
}

type Keys_EncryptFileClient interface {
	Send(*EncryptFileInput) error
	Recv() (*EncryptFileOutput, error)
	grpc.ClientStream
}

type keysEncryptFileClient struct {
	grpc.ClientStream
}

func (x *keysEncryptFileClient) Send(m *EncryptFileInput) error {
	return x.ClientStream.SendMsg(m)
}

func (x *keysEncryptFileClient) Recv() (*EncryptFileOutput, error) {
	m := new(EncryptFileOutput)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *keysClient) Decrypt(ctx context.Context, in *DecryptRequest, opts ...grpc.CallOption) (*DecryptResponse, error) {
	out := new(DecryptResponse)
	err := c.cc.Invoke(ctx, "/keys.Keys/Decrypt", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keysClient) DecryptStream(ctx context.Context, opts ...grpc.CallOption) (Keys_DecryptStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Keys_serviceDesc.Streams[8], "/keys.Keys/DecryptStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &keysDecryptStreamClient{stream}
	return x, nil
}

type Keys_DecryptStreamClient interface {
	Send(*DecryptInput) error
	Recv() (*DecryptOutput, error)
	grpc.ClientStream
}

type keysDecryptStreamClient struct {
	grpc.ClientStream
}

func (x *keysDecryptStreamClient) Send(m *DecryptInput) error {
	return x.ClientStream.SendMsg(m)
}

func (x *keysDecryptStreamClient) Recv() (*DecryptOutput, error) {
	m := new(DecryptOutput)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *keysClient) DecryptFile(ctx context.Context, opts ...grpc.CallOption) (Keys_DecryptFileClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Keys_serviceDesc.Streams[9], "/keys.Keys/DecryptFile", opts...)
	if err != nil {
		return nil, err
	}
	x := &keysDecryptFileClient{stream}
	return x, nil
}

type Keys_DecryptFileClient interface {
	Send(*DecryptFileInput) error
	Recv() (*DecryptFileOutput, error)
	grpc.ClientStream
}

type keysDecryptFileClient struct {
	grpc.ClientStream
}

func (x *keysDecryptFileClient) Send(m *DecryptFileInput) error {
	return x.ClientStream.SendMsg(m)
}

func (x *keysDecryptFileClient) Recv() (*DecryptFileOutput, error) {
	m := new(DecryptFileOutput)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *keysClient) Sigchain(ctx context.Context, in *SigchainRequest, opts ...grpc.CallOption) (*SigchainResponse, error) {
	out := new(SigchainResponse)
	err := c.cc.Invoke(ctx, "/keys.Keys/Sigchain", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keysClient) Statement(ctx context.Context, in *StatementRequest, opts ...grpc.CallOption) (*StatementResponse, error) {
	out := new(StatementResponse)
	err := c.cc.Invoke(ctx, "/keys.Keys/Statement", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keysClient) StatementCreate(ctx context.Context, in *StatementCreateRequest, opts ...grpc.CallOption) (*StatementCreateResponse, error) {
	out := new(StatementCreateResponse)
	err := c.cc.Invoke(ctx, "/keys.Keys/StatementCreate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keysClient) StatementRevoke(ctx context.Context, in *StatementRevokeRequest, opts ...grpc.CallOption) (*StatementRevokeResponse, error) {
	out := new(StatementRevokeResponse)
	err := c.cc.Invoke(ctx, "/keys.Keys/StatementRevoke", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keysClient) User(ctx context.Context, in *UserRequest, opts ...grpc.CallOption) (*UserResponse, error) {
	out := new(UserResponse)
	err := c.cc.Invoke(ctx, "/keys.Keys/User", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keysClient) UserSearch(ctx context.Context, in *UserSearchRequest, opts ...grpc.CallOption) (*UserSearchResponse, error) {
	out := new(UserSearchResponse)
	err := c.cc.Invoke(ctx, "/keys.Keys/UserSearch", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keysClient) UserService(ctx context.Context, in *UserServiceRequest, opts ...grpc.CallOption) (*UserServiceResponse, error) {
	out := new(UserServiceResponse)
	err := c.cc.Invoke(ctx, "/keys.Keys/UserService", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keysClient) UserSign(ctx context.Context, in *UserSignRequest, opts ...grpc.CallOption) (*UserSignResponse, error) {
	out := new(UserSignResponse)
	err := c.cc.Invoke(ctx, "/keys.Keys/UserSign", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keysClient) UserAdd(ctx context.Context, in *UserAddRequest, opts ...grpc.CallOption) (*UserAddResponse, error) {
	out := new(UserAddResponse)
	err := c.cc.Invoke(ctx, "/keys.Keys/UserAdd", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keysClient) Search(ctx context.Context, in *SearchRequest, opts ...grpc.CallOption) (*SearchResponse, error) {
	out := new(SearchResponse)
	err := c.cc.Invoke(ctx, "/keys.Keys/Search", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keysClient) Secret(ctx context.Context, in *SecretRequest, opts ...grpc.CallOption) (*SecretResponse, error) {
	out := new(SecretResponse)
	err := c.cc.Invoke(ctx, "/keys.Keys/Secret", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keysClient) SecretSave(ctx context.Context, in *SecretSaveRequest, opts ...grpc.CallOption) (*SecretSaveResponse, error) {
	out := new(SecretSaveResponse)
	err := c.cc.Invoke(ctx, "/keys.Keys/SecretSave", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keysClient) SecretRemove(ctx context.Context, in *SecretRemoveRequest, opts ...grpc.CallOption) (*SecretRemoveResponse, error) {
	out := new(SecretRemoveResponse)
	err := c.cc.Invoke(ctx, "/keys.Keys/SecretRemove", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keysClient) Secrets(ctx context.Context, in *SecretsRequest, opts ...grpc.CallOption) (*SecretsResponse, error) {
	out := new(SecretsResponse)
	err := c.cc.Invoke(ctx, "/keys.Keys/Secrets", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keysClient) Pull(ctx context.Context, in *PullRequest, opts ...grpc.CallOption) (*PullResponse, error) {
	out := new(PullResponse)
	err := c.cc.Invoke(ctx, "/keys.Keys/Pull", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keysClient) Push(ctx context.Context, in *PushRequest, opts ...grpc.CallOption) (*PushResponse, error) {
	out := new(PushResponse)
	err := c.cc.Invoke(ctx, "/keys.Keys/Push", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keysClient) Wormhole(ctx context.Context, opts ...grpc.CallOption) (Keys_WormholeClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Keys_serviceDesc.Streams[10], "/keys.Keys/Wormhole", opts...)
	if err != nil {
		return nil, err
	}
	x := &keysWormholeClient{stream}
	return x, nil
}

type Keys_WormholeClient interface {
	Send(*WormholeInput) error
	Recv() (*WormholeOutput, error)
	grpc.ClientStream
}

type keysWormholeClient struct {
	grpc.ClientStream
}

func (x *keysWormholeClient) Send(m *WormholeInput) error {
	return x.ClientStream.SendMsg(m)
}

func (x *keysWormholeClient) Recv() (*WormholeOutput, error) {
	m := new(WormholeOutput)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *keysClient) AuthSetup(ctx context.Context, in *AuthSetupRequest, opts ...grpc.CallOption) (*AuthSetupResponse, error) {
	out := new(AuthSetupResponse)
	err := c.cc.Invoke(ctx, "/keys.Keys/AuthSetup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keysClient) AuthVault(ctx context.Context, in *AuthVaultRequest, opts ...grpc.CallOption) (*AuthVaultResponse, error) {
	out := new(AuthVaultResponse)
	err := c.cc.Invoke(ctx, "/keys.Keys/AuthVault", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keysClient) AuthUnlock(ctx context.Context, in *AuthUnlockRequest, opts ...grpc.CallOption) (*AuthUnlockResponse, error) {
	out := new(AuthUnlockResponse)
	err := c.cc.Invoke(ctx, "/keys.Keys/AuthUnlock", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keysClient) AuthLock(ctx context.Context, in *AuthLockRequest, opts ...grpc.CallOption) (*AuthLockResponse, error) {
	out := new(AuthLockResponse)
	err := c.cc.Invoke(ctx, "/keys.Keys/AuthLock", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keysClient) AuthReset(ctx context.Context, in *AuthResetRequest, opts ...grpc.CallOption) (*AuthResetResponse, error) {
	out := new(AuthResetResponse)
	err := c.cc.Invoke(ctx, "/keys.Keys/AuthReset", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keysClient) AuthRecover(ctx context.Context, in *AuthRecoverRequest, opts ...grpc.CallOption) (*AuthRecoverResponse, error) {
	out := new(AuthRecoverResponse)
	err := c.cc.Invoke(ctx, "/keys.Keys/AuthRecover", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keysClient) RuntimeStatus(ctx context.Context, in *RuntimeStatusRequest, opts ...grpc.CallOption) (*RuntimeStatusResponse, error) {
	out := new(RuntimeStatusResponse)
	err := c.cc.Invoke(ctx, "/keys.Keys/RuntimeStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keysClient) Rand(ctx context.Context, in *RandRequest, opts ...grpc.CallOption) (*RandResponse, error) {
	out := new(RandResponse)
	err := c.cc.Invoke(ctx, "/keys.Keys/Rand", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keysClient) RandPassword(ctx context.Context, in *RandPasswordRequest, opts ...grpc.CallOption) (*RandPasswordResponse, error) {
	out := new(RandPasswordResponse)
	err := c.cc.Invoke(ctx, "/keys.Keys/RandPassword", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keysClient) AuthProvision(ctx context.Context, in *AuthProvisionRequest, opts ...grpc.CallOption) (*AuthProvisionResponse, error) {
	out := new(AuthProvisionResponse)
	err := c.cc.Invoke(ctx, "/keys.Keys/AuthProvision", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keysClient) AuthDeprovision(ctx context.Context, in *AuthDeprovisionRequest, opts ...grpc.CallOption) (*AuthDeprovisionResponse, error) {
	out := new(AuthDeprovisionResponse)
	err := c.cc.Invoke(ctx, "/keys.Keys/AuthDeprovision", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keysClient) AuthProvisions(ctx context.Context, in *AuthProvisionsRequest, opts ...grpc.CallOption) (*AuthProvisionsResponse, error) {
	out := new(AuthProvisionsResponse)
	err := c.cc.Invoke(ctx, "/keys.Keys/AuthProvisions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keysClient) AuthPasswordChange(ctx context.Context, in *AuthPasswordChangeRequest, opts ...grpc.CallOption) (*AuthPasswordChangeResponse, error) {
	out := new(AuthPasswordChangeResponse)
	err := c.cc.Invoke(ctx, "/keys.Keys/AuthPasswordChange", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keysClient) VaultAuth(ctx context.Context, in *VaultAuthRequest, opts ...grpc.CallOption) (*VaultAuthResponse, error) {
	out := new(VaultAuthResponse)
	err := c.cc.Invoke(ctx, "/keys.Keys/VaultAuth", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keysClient) VaultSync(ctx context.Context, in *VaultSyncRequest, opts ...grpc.CallOption) (*VaultSyncResponse, error) {
	out := new(VaultSyncResponse)
	err := c.cc.Invoke(ctx, "/keys.Keys/VaultSync", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keysClient) VaultUnsync(ctx context.Context, in *VaultUnsyncRequest, opts ...grpc.CallOption) (*VaultUnsyncResponse, error) {
	out := new(VaultUnsyncResponse)
	err := c.cc.Invoke(ctx, "/keys.Keys/VaultUnsync", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keysClient) VaultStatus(ctx context.Context, in *VaultStatusRequest, opts ...grpc.CallOption) (*VaultStatusResponse, error) {
	out := new(VaultStatusResponse)
	err := c.cc.Invoke(ctx, "/keys.Keys/VaultStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keysClient) VaultUpdate(ctx context.Context, in *VaultUpdateRequest, opts ...grpc.CallOption) (*VaultUpdateResponse, error) {
	out := new(VaultUpdateResponse)
	err := c.cc.Invoke(ctx, "/keys.Keys/VaultUpdate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keysClient) Collections(ctx context.Context, in *CollectionsRequest, opts ...grpc.CallOption) (*CollectionsResponse, error) {
	out := new(CollectionsResponse)
	err := c.cc.Invoke(ctx, "/keys.Keys/Collections", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keysClient) Documents(ctx context.Context, in *DocumentsRequest, opts ...grpc.CallOption) (*DocumentsResponse, error) {
	out := new(DocumentsResponse)
	err := c.cc.Invoke(ctx, "/keys.Keys/Documents", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keysClient) DocumentDelete(ctx context.Context, in *DocumentDeleteRequest, opts ...grpc.CallOption) (*DocumentDeleteResponse, error) {
	out := new(DocumentDeleteResponse)
	err := c.cc.Invoke(ctx, "/keys.Keys/DocumentDelete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keysClient) ConfigGet(ctx context.Context, in *ConfigGetRequest, opts ...grpc.CallOption) (*ConfigGetResponse, error) {
	out := new(ConfigGetResponse)
	err := c.cc.Invoke(ctx, "/keys.Keys/ConfigGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keysClient) ConfigSet(ctx context.Context, in *ConfigSetRequest, opts ...grpc.CallOption) (*ConfigSetResponse, error) {
	out := new(ConfigSetResponse)
	err := c.cc.Invoke(ctx, "/keys.Keys/ConfigSet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keysClient) AdminSignURL(ctx context.Context, in *AdminSignURLRequest, opts ...grpc.CallOption) (*AdminSignURLResponse, error) {
	out := new(AdminSignURLResponse)
	err := c.cc.Invoke(ctx, "/keys.Keys/AdminSignURL", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keysClient) AdminCheck(ctx context.Context, in *AdminCheckRequest, opts ...grpc.CallOption) (*AdminCheckResponse, error) {
	out := new(AdminCheckResponse)
	err := c.cc.Invoke(ctx, "/keys.Keys/AdminCheck", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keysClient) Channels(ctx context.Context, in *ChannelsRequest, opts ...grpc.CallOption) (*ChannelsResponse, error) {
	out := new(ChannelsResponse)
	err := c.cc.Invoke(ctx, "/keys.Keys/Channels", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keysClient) ChannelCreate(ctx context.Context, in *ChannelCreateRequest, opts ...grpc.CallOption) (*ChannelCreateResponse, error) {
	out := new(ChannelCreateResponse)
	err := c.cc.Invoke(ctx, "/keys.Keys/ChannelCreate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keysClient) ChannelUsers(ctx context.Context, in *ChannelUsersRequest, opts ...grpc.CallOption) (*ChannelUsersResponse, error) {
	out := new(ChannelUsersResponse)
	err := c.cc.Invoke(ctx, "/keys.Keys/ChannelUsers", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keysClient) ChannelInvitesCreate(ctx context.Context, in *ChannelInvitesCreateRequest, opts ...grpc.CallOption) (*ChannelInvitesCreateResponse, error) {
	out := new(ChannelInvitesCreateResponse)
	err := c.cc.Invoke(ctx, "/keys.Keys/ChannelInvitesCreate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keysClient) ChannelUninvite(ctx context.Context, in *ChannelUninviteRequest, opts ...grpc.CallOption) (*ChannelUninviteResponse, error) {
	out := new(ChannelUninviteResponse)
	err := c.cc.Invoke(ctx, "/keys.Keys/ChannelUninvite", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keysClient) ChannelInvites(ctx context.Context, in *ChannelInvitesRequest, opts ...grpc.CallOption) (*ChannelInvitesResponse, error) {
	out := new(ChannelInvitesResponse)
	err := c.cc.Invoke(ctx, "/keys.Keys/ChannelInvites", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keysClient) ChannelUserInvites(ctx context.Context, in *ChannelUserInvitesRequest, opts ...grpc.CallOption) (*ChannelUserInvitesResponse, error) {
	out := new(ChannelUserInvitesResponse)
	err := c.cc.Invoke(ctx, "/keys.Keys/ChannelUserInvites", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keysClient) ChannelJoin(ctx context.Context, in *ChannelJoinRequest, opts ...grpc.CallOption) (*ChannelJoinResponse, error) {
	out := new(ChannelJoinResponse)
	err := c.cc.Invoke(ctx, "/keys.Keys/ChannelJoin", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keysClient) ChannelLeave(ctx context.Context, in *ChannelLeaveRequest, opts ...grpc.CallOption) (*ChannelLeaveResponse, error) {
	out := new(ChannelLeaveResponse)
	err := c.cc.Invoke(ctx, "/keys.Keys/ChannelLeave", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keysClient) MessagePrepare(ctx context.Context, in *MessagePrepareRequest, opts ...grpc.CallOption) (*MessagePrepareResponse, error) {
	out := new(MessagePrepareResponse)
	err := c.cc.Invoke(ctx, "/keys.Keys/MessagePrepare", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keysClient) MessageCreate(ctx context.Context, in *MessageCreateRequest, opts ...grpc.CallOption) (*MessageCreateResponse, error) {
	out := new(MessageCreateResponse)
	err := c.cc.Invoke(ctx, "/keys.Keys/MessageCreate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keysClient) Messages(ctx context.Context, in *MessagesRequest, opts ...grpc.CallOption) (*MessagesResponse, error) {
	out := new(MessagesResponse)
	err := c.cc.Invoke(ctx, "/keys.Keys/Messages", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *keysClient) Relay(ctx context.Context, in *RelayRequest, opts ...grpc.CallOption) (Keys_RelayClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Keys_serviceDesc.Streams[11], "/keys.Keys/Relay", opts...)
	if err != nil {
		return nil, err
	}
	x := &keysRelayClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Keys_RelayClient interface {
	Recv() (*RelayOutput, error)
	grpc.ClientStream
}

type keysRelayClient struct {
	grpc.ClientStream
}

func (x *keysRelayClient) Recv() (*RelayOutput, error) {
	m := new(RelayOutput)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// KeysServer is the server API for Keys service.
// All implementations must embed UnimplementedKeysServer
// for forward compatibility
type KeysServer interface {
	KeyGenerate(context.Context, *KeyGenerateRequest) (*KeyGenerateResponse, error)
	Keys(context.Context, *KeysRequest) (*KeysResponse, error)
	Key(context.Context, *KeyRequest) (*KeyResponse, error)
	KeyImport(context.Context, *KeyImportRequest) (*KeyImportResponse, error)
	KeyExport(context.Context, *KeyExportRequest) (*KeyExportResponse, error)
	KeyRemove(context.Context, *KeyRemoveRequest) (*KeyRemoveResponse, error)
	Sign(context.Context, *SignRequest) (*SignResponse, error)
	SignFile(Keys_SignFileServer) error
	SignStream(Keys_SignStreamServer) error
	Verify(context.Context, *VerifyRequest) (*VerifyResponse, error)
	VerifyFile(Keys_VerifyFileServer) error
	VerifyStream(Keys_VerifyStreamServer) error
	VerifyDetached(context.Context, *VerifyDetachedRequest) (*VerifyDetachedResponse, error)
	VerifyDetachedFile(Keys_VerifyDetachedFileServer) error
	VerifyDetachedStream(Keys_VerifyDetachedStreamServer) error
	Encrypt(context.Context, *EncryptRequest) (*EncryptResponse, error)
	EncryptStream(Keys_EncryptStreamServer) error
	EncryptFile(Keys_EncryptFileServer) error
	Decrypt(context.Context, *DecryptRequest) (*DecryptResponse, error)
	DecryptStream(Keys_DecryptStreamServer) error
	DecryptFile(Keys_DecryptFileServer) error
	Sigchain(context.Context, *SigchainRequest) (*SigchainResponse, error)
	Statement(context.Context, *StatementRequest) (*StatementResponse, error)
	StatementCreate(context.Context, *StatementCreateRequest) (*StatementCreateResponse, error)
	StatementRevoke(context.Context, *StatementRevokeRequest) (*StatementRevokeResponse, error)
	User(context.Context, *UserRequest) (*UserResponse, error)
	UserSearch(context.Context, *UserSearchRequest) (*UserSearchResponse, error)
	UserService(context.Context, *UserServiceRequest) (*UserServiceResponse, error)
	UserSign(context.Context, *UserSignRequest) (*UserSignResponse, error)
	UserAdd(context.Context, *UserAddRequest) (*UserAddResponse, error)
	Search(context.Context, *SearchRequest) (*SearchResponse, error)
	Secret(context.Context, *SecretRequest) (*SecretResponse, error)
	SecretSave(context.Context, *SecretSaveRequest) (*SecretSaveResponse, error)
	SecretRemove(context.Context, *SecretRemoveRequest) (*SecretRemoveResponse, error)
	Secrets(context.Context, *SecretsRequest) (*SecretsResponse, error)
	Pull(context.Context, *PullRequest) (*PullResponse, error)
	Push(context.Context, *PushRequest) (*PushResponse, error)
	Wormhole(Keys_WormholeServer) error
	// These requests do not need auth.
	// BEGIN NO AUTH
	AuthSetup(context.Context, *AuthSetupRequest) (*AuthSetupResponse, error)
	AuthVault(context.Context, *AuthVaultRequest) (*AuthVaultResponse, error)
	AuthUnlock(context.Context, *AuthUnlockRequest) (*AuthUnlockResponse, error)
	AuthLock(context.Context, *AuthLockRequest) (*AuthLockResponse, error)
	AuthReset(context.Context, *AuthResetRequest) (*AuthResetResponse, error)
	AuthRecover(context.Context, *AuthRecoverRequest) (*AuthRecoverResponse, error)
	RuntimeStatus(context.Context, *RuntimeStatusRequest) (*RuntimeStatusResponse, error)
	Rand(context.Context, *RandRequest) (*RandResponse, error)
	RandPassword(context.Context, *RandPasswordRequest) (*RandPasswordResponse, error)
	// Auth (edit)
	AuthProvision(context.Context, *AuthProvisionRequest) (*AuthProvisionResponse, error)
	AuthDeprovision(context.Context, *AuthDeprovisionRequest) (*AuthDeprovisionResponse, error)
	AuthProvisions(context.Context, *AuthProvisionsRequest) (*AuthProvisionsResponse, error)
	AuthPasswordChange(context.Context, *AuthPasswordChangeRequest) (*AuthPasswordChangeResponse, error)
	// Vault
	VaultAuth(context.Context, *VaultAuthRequest) (*VaultAuthResponse, error)
	VaultSync(context.Context, *VaultSyncRequest) (*VaultSyncResponse, error)
	VaultUnsync(context.Context, *VaultUnsyncRequest) (*VaultUnsyncResponse, error)
	VaultStatus(context.Context, *VaultStatusRequest) (*VaultStatusResponse, error)
	VaultUpdate(context.Context, *VaultUpdateRequest) (*VaultUpdateResponse, error)
	// DB
	Collections(context.Context, *CollectionsRequest) (*CollectionsResponse, error)
	Documents(context.Context, *DocumentsRequest) (*DocumentsResponse, error)
	DocumentDelete(context.Context, *DocumentDeleteRequest) (*DocumentDeleteResponse, error)
	// Config
	ConfigGet(context.Context, *ConfigGetRequest) (*ConfigGetResponse, error)
	ConfigSet(context.Context, *ConfigSetRequest) (*ConfigSetResponse, error)
	// Admin
	AdminSignURL(context.Context, *AdminSignURLRequest) (*AdminSignURLResponse, error)
	AdminCheck(context.Context, *AdminCheckRequest) (*AdminCheckResponse, error)
	// Channels
	Channels(context.Context, *ChannelsRequest) (*ChannelsResponse, error)
	ChannelCreate(context.Context, *ChannelCreateRequest) (*ChannelCreateResponse, error)
	ChannelUsers(context.Context, *ChannelUsersRequest) (*ChannelUsersResponse, error)
	ChannelInvitesCreate(context.Context, *ChannelInvitesCreateRequest) (*ChannelInvitesCreateResponse, error)
	ChannelUninvite(context.Context, *ChannelUninviteRequest) (*ChannelUninviteResponse, error)
	ChannelInvites(context.Context, *ChannelInvitesRequest) (*ChannelInvitesResponse, error)
	ChannelUserInvites(context.Context, *ChannelUserInvitesRequest) (*ChannelUserInvitesResponse, error)
	ChannelJoin(context.Context, *ChannelJoinRequest) (*ChannelJoinResponse, error)
	ChannelLeave(context.Context, *ChannelLeaveRequest) (*ChannelLeaveResponse, error)
	// Messages
	MessagePrepare(context.Context, *MessagePrepareRequest) (*MessagePrepareResponse, error)
	MessageCreate(context.Context, *MessageCreateRequest) (*MessageCreateResponse, error)
	Messages(context.Context, *MessagesRequest) (*MessagesResponse, error)
	// Relay
	Relay(*RelayRequest, Keys_RelayServer) error
	mustEmbedUnimplementedKeysServer()
}

// UnimplementedKeysServer must be embedded to have forward compatible implementations.
type UnimplementedKeysServer struct {
}

func (*UnimplementedKeysServer) KeyGenerate(context.Context, *KeyGenerateRequest) (*KeyGenerateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method KeyGenerate not implemented")
}
func (*UnimplementedKeysServer) Keys(context.Context, *KeysRequest) (*KeysResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Keys not implemented")
}
func (*UnimplementedKeysServer) Key(context.Context, *KeyRequest) (*KeyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Key not implemented")
}
func (*UnimplementedKeysServer) KeyImport(context.Context, *KeyImportRequest) (*KeyImportResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method KeyImport not implemented")
}
func (*UnimplementedKeysServer) KeyExport(context.Context, *KeyExportRequest) (*KeyExportResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method KeyExport not implemented")
}
func (*UnimplementedKeysServer) KeyRemove(context.Context, *KeyRemoveRequest) (*KeyRemoveResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method KeyRemove not implemented")
}
func (*UnimplementedKeysServer) Sign(context.Context, *SignRequest) (*SignResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Sign not implemented")
}
func (*UnimplementedKeysServer) SignFile(Keys_SignFileServer) error {
	return status.Errorf(codes.Unimplemented, "method SignFile not implemented")
}
func (*UnimplementedKeysServer) SignStream(Keys_SignStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method SignStream not implemented")
}
func (*UnimplementedKeysServer) Verify(context.Context, *VerifyRequest) (*VerifyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Verify not implemented")
}
func (*UnimplementedKeysServer) VerifyFile(Keys_VerifyFileServer) error {
	return status.Errorf(codes.Unimplemented, "method VerifyFile not implemented")
}
func (*UnimplementedKeysServer) VerifyStream(Keys_VerifyStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method VerifyStream not implemented")
}
func (*UnimplementedKeysServer) VerifyDetached(context.Context, *VerifyDetachedRequest) (*VerifyDetachedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VerifyDetached not implemented")
}
func (*UnimplementedKeysServer) VerifyDetachedFile(Keys_VerifyDetachedFileServer) error {
	return status.Errorf(codes.Unimplemented, "method VerifyDetachedFile not implemented")
}
func (*UnimplementedKeysServer) VerifyDetachedStream(Keys_VerifyDetachedStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method VerifyDetachedStream not implemented")
}
func (*UnimplementedKeysServer) Encrypt(context.Context, *EncryptRequest) (*EncryptResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Encrypt not implemented")
}
func (*UnimplementedKeysServer) EncryptStream(Keys_EncryptStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method EncryptStream not implemented")
}
func (*UnimplementedKeysServer) EncryptFile(Keys_EncryptFileServer) error {
	return status.Errorf(codes.Unimplemented, "method EncryptFile not implemented")
}
func (*UnimplementedKeysServer) Decrypt(context.Context, *DecryptRequest) (*DecryptResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Decrypt not implemented")
}
func (*UnimplementedKeysServer) DecryptStream(Keys_DecryptStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method DecryptStream not implemented")
}
func (*UnimplementedKeysServer) DecryptFile(Keys_DecryptFileServer) error {
	return status.Errorf(codes.Unimplemented, "method DecryptFile not implemented")
}
func (*UnimplementedKeysServer) Sigchain(context.Context, *SigchainRequest) (*SigchainResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Sigchain not implemented")
}
func (*UnimplementedKeysServer) Statement(context.Context, *StatementRequest) (*StatementResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Statement not implemented")
}
func (*UnimplementedKeysServer) StatementCreate(context.Context, *StatementCreateRequest) (*StatementCreateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StatementCreate not implemented")
}
func (*UnimplementedKeysServer) StatementRevoke(context.Context, *StatementRevokeRequest) (*StatementRevokeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StatementRevoke not implemented")
}
func (*UnimplementedKeysServer) User(context.Context, *UserRequest) (*UserResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method User not implemented")
}
func (*UnimplementedKeysServer) UserSearch(context.Context, *UserSearchRequest) (*UserSearchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserSearch not implemented")
}
func (*UnimplementedKeysServer) UserService(context.Context, *UserServiceRequest) (*UserServiceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserService not implemented")
}
func (*UnimplementedKeysServer) UserSign(context.Context, *UserSignRequest) (*UserSignResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserSign not implemented")
}
func (*UnimplementedKeysServer) UserAdd(context.Context, *UserAddRequest) (*UserAddResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserAdd not implemented")
}
func (*UnimplementedKeysServer) Search(context.Context, *SearchRequest) (*SearchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Search not implemented")
}
func (*UnimplementedKeysServer) Secret(context.Context, *SecretRequest) (*SecretResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Secret not implemented")
}
func (*UnimplementedKeysServer) SecretSave(context.Context, *SecretSaveRequest) (*SecretSaveResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SecretSave not implemented")
}
func (*UnimplementedKeysServer) SecretRemove(context.Context, *SecretRemoveRequest) (*SecretRemoveResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SecretRemove not implemented")
}
func (*UnimplementedKeysServer) Secrets(context.Context, *SecretsRequest) (*SecretsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Secrets not implemented")
}
func (*UnimplementedKeysServer) Pull(context.Context, *PullRequest) (*PullResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Pull not implemented")
}
func (*UnimplementedKeysServer) Push(context.Context, *PushRequest) (*PushResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Push not implemented")
}
func (*UnimplementedKeysServer) Wormhole(Keys_WormholeServer) error {
	return status.Errorf(codes.Unimplemented, "method Wormhole not implemented")
}
func (*UnimplementedKeysServer) AuthSetup(context.Context, *AuthSetupRequest) (*AuthSetupResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AuthSetup not implemented")
}
func (*UnimplementedKeysServer) AuthVault(context.Context, *AuthVaultRequest) (*AuthVaultResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AuthVault not implemented")
}
func (*UnimplementedKeysServer) AuthUnlock(context.Context, *AuthUnlockRequest) (*AuthUnlockResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AuthUnlock not implemented")
}
func (*UnimplementedKeysServer) AuthLock(context.Context, *AuthLockRequest) (*AuthLockResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AuthLock not implemented")
}
func (*UnimplementedKeysServer) AuthReset(context.Context, *AuthResetRequest) (*AuthResetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AuthReset not implemented")
}
func (*UnimplementedKeysServer) AuthRecover(context.Context, *AuthRecoverRequest) (*AuthRecoverResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AuthRecover not implemented")
}
func (*UnimplementedKeysServer) RuntimeStatus(context.Context, *RuntimeStatusRequest) (*RuntimeStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RuntimeStatus not implemented")
}
func (*UnimplementedKeysServer) Rand(context.Context, *RandRequest) (*RandResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Rand not implemented")
}
func (*UnimplementedKeysServer) RandPassword(context.Context, *RandPasswordRequest) (*RandPasswordResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RandPassword not implemented")
}
func (*UnimplementedKeysServer) AuthProvision(context.Context, *AuthProvisionRequest) (*AuthProvisionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AuthProvision not implemented")
}
func (*UnimplementedKeysServer) AuthDeprovision(context.Context, *AuthDeprovisionRequest) (*AuthDeprovisionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AuthDeprovision not implemented")
}
func (*UnimplementedKeysServer) AuthProvisions(context.Context, *AuthProvisionsRequest) (*AuthProvisionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AuthProvisions not implemented")
}
func (*UnimplementedKeysServer) AuthPasswordChange(context.Context, *AuthPasswordChangeRequest) (*AuthPasswordChangeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AuthPasswordChange not implemented")
}
func (*UnimplementedKeysServer) VaultAuth(context.Context, *VaultAuthRequest) (*VaultAuthResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VaultAuth not implemented")
}
func (*UnimplementedKeysServer) VaultSync(context.Context, *VaultSyncRequest) (*VaultSyncResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VaultSync not implemented")
}
func (*UnimplementedKeysServer) VaultUnsync(context.Context, *VaultUnsyncRequest) (*VaultUnsyncResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VaultUnsync not implemented")
}
func (*UnimplementedKeysServer) VaultStatus(context.Context, *VaultStatusRequest) (*VaultStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VaultStatus not implemented")
}
func (*UnimplementedKeysServer) VaultUpdate(context.Context, *VaultUpdateRequest) (*VaultUpdateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VaultUpdate not implemented")
}
func (*UnimplementedKeysServer) Collections(context.Context, *CollectionsRequest) (*CollectionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Collections not implemented")
}
func (*UnimplementedKeysServer) Documents(context.Context, *DocumentsRequest) (*DocumentsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Documents not implemented")
}
func (*UnimplementedKeysServer) DocumentDelete(context.Context, *DocumentDeleteRequest) (*DocumentDeleteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DocumentDelete not implemented")
}
func (*UnimplementedKeysServer) ConfigGet(context.Context, *ConfigGetRequest) (*ConfigGetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfigGet not implemented")
}
func (*UnimplementedKeysServer) ConfigSet(context.Context, *ConfigSetRequest) (*ConfigSetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfigSet not implemented")
}
func (*UnimplementedKeysServer) AdminSignURL(context.Context, *AdminSignURLRequest) (*AdminSignURLResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AdminSignURL not implemented")
}
func (*UnimplementedKeysServer) AdminCheck(context.Context, *AdminCheckRequest) (*AdminCheckResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AdminCheck not implemented")
}
func (*UnimplementedKeysServer) Channels(context.Context, *ChannelsRequest) (*ChannelsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Channels not implemented")
}
func (*UnimplementedKeysServer) ChannelCreate(context.Context, *ChannelCreateRequest) (*ChannelCreateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ChannelCreate not implemented")
}
func (*UnimplementedKeysServer) ChannelUsers(context.Context, *ChannelUsersRequest) (*ChannelUsersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ChannelUsers not implemented")
}
func (*UnimplementedKeysServer) ChannelInvitesCreate(context.Context, *ChannelInvitesCreateRequest) (*ChannelInvitesCreateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ChannelInvitesCreate not implemented")
}
func (*UnimplementedKeysServer) ChannelUninvite(context.Context, *ChannelUninviteRequest) (*ChannelUninviteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ChannelUninvite not implemented")
}
func (*UnimplementedKeysServer) ChannelInvites(context.Context, *ChannelInvitesRequest) (*ChannelInvitesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ChannelInvites not implemented")
}
func (*UnimplementedKeysServer) ChannelUserInvites(context.Context, *ChannelUserInvitesRequest) (*ChannelUserInvitesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ChannelUserInvites not implemented")
}
func (*UnimplementedKeysServer) ChannelJoin(context.Context, *ChannelJoinRequest) (*ChannelJoinResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ChannelJoin not implemented")
}
func (*UnimplementedKeysServer) ChannelLeave(context.Context, *ChannelLeaveRequest) (*ChannelLeaveResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ChannelLeave not implemented")
}
func (*UnimplementedKeysServer) MessagePrepare(context.Context, *MessagePrepareRequest) (*MessagePrepareResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MessagePrepare not implemented")
}
func (*UnimplementedKeysServer) MessageCreate(context.Context, *MessageCreateRequest) (*MessageCreateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MessageCreate not implemented")
}
func (*UnimplementedKeysServer) Messages(context.Context, *MessagesRequest) (*MessagesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Messages not implemented")
}
func (*UnimplementedKeysServer) Relay(*RelayRequest, Keys_RelayServer) error {
	return status.Errorf(codes.Unimplemented, "method Relay not implemented")
}
func (*UnimplementedKeysServer) mustEmbedUnimplementedKeysServer() {}

func RegisterKeysServer(s *grpc.Server, srv KeysServer) {
	s.RegisterService(&_Keys_serviceDesc, srv)
}

func _Keys_KeyGenerate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KeyGenerateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeysServer).KeyGenerate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/keys.Keys/KeyGenerate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeysServer).KeyGenerate(ctx, req.(*KeyGenerateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Keys_Keys_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KeysRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeysServer).Keys(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/keys.Keys/Keys",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeysServer).Keys(ctx, req.(*KeysRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Keys_Key_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeysServer).Key(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/keys.Keys/Key",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeysServer).Key(ctx, req.(*KeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Keys_KeyImport_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KeyImportRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeysServer).KeyImport(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/keys.Keys/KeyImport",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeysServer).KeyImport(ctx, req.(*KeyImportRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Keys_KeyExport_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KeyExportRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeysServer).KeyExport(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/keys.Keys/KeyExport",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeysServer).KeyExport(ctx, req.(*KeyExportRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Keys_KeyRemove_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KeyRemoveRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeysServer).KeyRemove(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/keys.Keys/KeyRemove",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeysServer).KeyRemove(ctx, req.(*KeyRemoveRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Keys_Sign_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SignRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeysServer).Sign(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/keys.Keys/Sign",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeysServer).Sign(ctx, req.(*SignRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Keys_SignFile_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(KeysServer).SignFile(&keysSignFileServer{stream})
}

type Keys_SignFileServer interface {
	Send(*SignFileOutput) error
	Recv() (*SignFileInput, error)
	grpc.ServerStream
}

type keysSignFileServer struct {
	grpc.ServerStream
}

func (x *keysSignFileServer) Send(m *SignFileOutput) error {
	return x.ServerStream.SendMsg(m)
}

func (x *keysSignFileServer) Recv() (*SignFileInput, error) {
	m := new(SignFileInput)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Keys_SignStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(KeysServer).SignStream(&keysSignStreamServer{stream})
}

type Keys_SignStreamServer interface {
	Send(*SignOutput) error
	Recv() (*SignInput, error)
	grpc.ServerStream
}

type keysSignStreamServer struct {
	grpc.ServerStream
}

func (x *keysSignStreamServer) Send(m *SignOutput) error {
	return x.ServerStream.SendMsg(m)
}

func (x *keysSignStreamServer) Recv() (*SignInput, error) {
	m := new(SignInput)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Keys_Verify_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VerifyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeysServer).Verify(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/keys.Keys/Verify",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeysServer).Verify(ctx, req.(*VerifyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Keys_VerifyFile_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(KeysServer).VerifyFile(&keysVerifyFileServer{stream})
}

type Keys_VerifyFileServer interface {
	Send(*VerifyFileOutput) error
	Recv() (*VerifyFileInput, error)
	grpc.ServerStream
}

type keysVerifyFileServer struct {
	grpc.ServerStream
}

func (x *keysVerifyFileServer) Send(m *VerifyFileOutput) error {
	return x.ServerStream.SendMsg(m)
}

func (x *keysVerifyFileServer) Recv() (*VerifyFileInput, error) {
	m := new(VerifyFileInput)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Keys_VerifyStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(KeysServer).VerifyStream(&keysVerifyStreamServer{stream})
}

type Keys_VerifyStreamServer interface {
	Send(*VerifyOutput) error
	Recv() (*VerifyInput, error)
	grpc.ServerStream
}

type keysVerifyStreamServer struct {
	grpc.ServerStream
}

func (x *keysVerifyStreamServer) Send(m *VerifyOutput) error {
	return x.ServerStream.SendMsg(m)
}

func (x *keysVerifyStreamServer) Recv() (*VerifyInput, error) {
	m := new(VerifyInput)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Keys_VerifyDetached_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VerifyDetachedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeysServer).VerifyDetached(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/keys.Keys/VerifyDetached",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeysServer).VerifyDetached(ctx, req.(*VerifyDetachedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Keys_VerifyDetachedFile_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(KeysServer).VerifyDetachedFile(&keysVerifyDetachedFileServer{stream})
}

type Keys_VerifyDetachedFileServer interface {
	SendAndClose(*VerifyDetachedResponse) error
	Recv() (*VerifyDetachedFileInput, error)
	grpc.ServerStream
}

type keysVerifyDetachedFileServer struct {
	grpc.ServerStream
}

func (x *keysVerifyDetachedFileServer) SendAndClose(m *VerifyDetachedResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *keysVerifyDetachedFileServer) Recv() (*VerifyDetachedFileInput, error) {
	m := new(VerifyDetachedFileInput)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Keys_VerifyDetachedStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(KeysServer).VerifyDetachedStream(&keysVerifyDetachedStreamServer{stream})
}

type Keys_VerifyDetachedStreamServer interface {
	SendAndClose(*VerifyDetachedResponse) error
	Recv() (*VerifyDetachedInput, error)
	grpc.ServerStream
}

type keysVerifyDetachedStreamServer struct {
	grpc.ServerStream
}

func (x *keysVerifyDetachedStreamServer) SendAndClose(m *VerifyDetachedResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *keysVerifyDetachedStreamServer) Recv() (*VerifyDetachedInput, error) {
	m := new(VerifyDetachedInput)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Keys_Encrypt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EncryptRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeysServer).Encrypt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/keys.Keys/Encrypt",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeysServer).Encrypt(ctx, req.(*EncryptRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Keys_EncryptStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(KeysServer).EncryptStream(&keysEncryptStreamServer{stream})
}

type Keys_EncryptStreamServer interface {
	Send(*EncryptOutput) error
	Recv() (*EncryptInput, error)
	grpc.ServerStream
}

type keysEncryptStreamServer struct {
	grpc.ServerStream
}

func (x *keysEncryptStreamServer) Send(m *EncryptOutput) error {
	return x.ServerStream.SendMsg(m)
}

func (x *keysEncryptStreamServer) Recv() (*EncryptInput, error) {
	m := new(EncryptInput)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Keys_EncryptFile_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(KeysServer).EncryptFile(&keysEncryptFileServer{stream})
}

type Keys_EncryptFileServer interface {
	Send(*EncryptFileOutput) error
	Recv() (*EncryptFileInput, error)
	grpc.ServerStream
}

type keysEncryptFileServer struct {
	grpc.ServerStream
}

func (x *keysEncryptFileServer) Send(m *EncryptFileOutput) error {
	return x.ServerStream.SendMsg(m)
}

func (x *keysEncryptFileServer) Recv() (*EncryptFileInput, error) {
	m := new(EncryptFileInput)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Keys_Decrypt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DecryptRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeysServer).Decrypt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/keys.Keys/Decrypt",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeysServer).Decrypt(ctx, req.(*DecryptRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Keys_DecryptStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(KeysServer).DecryptStream(&keysDecryptStreamServer{stream})
}

type Keys_DecryptStreamServer interface {
	Send(*DecryptOutput) error
	Recv() (*DecryptInput, error)
	grpc.ServerStream
}

type keysDecryptStreamServer struct {
	grpc.ServerStream
}

func (x *keysDecryptStreamServer) Send(m *DecryptOutput) error {
	return x.ServerStream.SendMsg(m)
}

func (x *keysDecryptStreamServer) Recv() (*DecryptInput, error) {
	m := new(DecryptInput)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Keys_DecryptFile_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(KeysServer).DecryptFile(&keysDecryptFileServer{stream})
}

type Keys_DecryptFileServer interface {
	Send(*DecryptFileOutput) error
	Recv() (*DecryptFileInput, error)
	grpc.ServerStream
}

type keysDecryptFileServer struct {
	grpc.ServerStream
}

func (x *keysDecryptFileServer) Send(m *DecryptFileOutput) error {
	return x.ServerStream.SendMsg(m)
}

func (x *keysDecryptFileServer) Recv() (*DecryptFileInput, error) {
	m := new(DecryptFileInput)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Keys_Sigchain_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SigchainRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeysServer).Sigchain(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/keys.Keys/Sigchain",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeysServer).Sigchain(ctx, req.(*SigchainRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Keys_Statement_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StatementRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeysServer).Statement(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/keys.Keys/Statement",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeysServer).Statement(ctx, req.(*StatementRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Keys_StatementCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StatementCreateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeysServer).StatementCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/keys.Keys/StatementCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeysServer).StatementCreate(ctx, req.(*StatementCreateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Keys_StatementRevoke_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StatementRevokeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeysServer).StatementRevoke(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/keys.Keys/StatementRevoke",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeysServer).StatementRevoke(ctx, req.(*StatementRevokeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Keys_User_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeysServer).User(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/keys.Keys/User",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeysServer).User(ctx, req.(*UserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Keys_UserSearch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserSearchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeysServer).UserSearch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/keys.Keys/UserSearch",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeysServer).UserSearch(ctx, req.(*UserSearchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Keys_UserService_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserServiceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeysServer).UserService(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/keys.Keys/UserService",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeysServer).UserService(ctx, req.(*UserServiceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Keys_UserSign_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserSignRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeysServer).UserSign(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/keys.Keys/UserSign",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeysServer).UserSign(ctx, req.(*UserSignRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Keys_UserAdd_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserAddRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeysServer).UserAdd(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/keys.Keys/UserAdd",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeysServer).UserAdd(ctx, req.(*UserAddRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Keys_Search_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeysServer).Search(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/keys.Keys/Search",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeysServer).Search(ctx, req.(*SearchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Keys_Secret_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SecretRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeysServer).Secret(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/keys.Keys/Secret",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeysServer).Secret(ctx, req.(*SecretRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Keys_SecretSave_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SecretSaveRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeysServer).SecretSave(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/keys.Keys/SecretSave",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeysServer).SecretSave(ctx, req.(*SecretSaveRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Keys_SecretRemove_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SecretRemoveRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeysServer).SecretRemove(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/keys.Keys/SecretRemove",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeysServer).SecretRemove(ctx, req.(*SecretRemoveRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Keys_Secrets_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SecretsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeysServer).Secrets(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/keys.Keys/Secrets",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeysServer).Secrets(ctx, req.(*SecretsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Keys_Pull_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PullRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeysServer).Pull(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/keys.Keys/Pull",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeysServer).Pull(ctx, req.(*PullRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Keys_Push_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PushRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeysServer).Push(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/keys.Keys/Push",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeysServer).Push(ctx, req.(*PushRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Keys_Wormhole_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(KeysServer).Wormhole(&keysWormholeServer{stream})
}

type Keys_WormholeServer interface {
	Send(*WormholeOutput) error
	Recv() (*WormholeInput, error)
	grpc.ServerStream
}

type keysWormholeServer struct {
	grpc.ServerStream
}

func (x *keysWormholeServer) Send(m *WormholeOutput) error {
	return x.ServerStream.SendMsg(m)
}

func (x *keysWormholeServer) Recv() (*WormholeInput, error) {
	m := new(WormholeInput)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Keys_AuthSetup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AuthSetupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeysServer).AuthSetup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/keys.Keys/AuthSetup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeysServer).AuthSetup(ctx, req.(*AuthSetupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Keys_AuthVault_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AuthVaultRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeysServer).AuthVault(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/keys.Keys/AuthVault",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeysServer).AuthVault(ctx, req.(*AuthVaultRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Keys_AuthUnlock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AuthUnlockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeysServer).AuthUnlock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/keys.Keys/AuthUnlock",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeysServer).AuthUnlock(ctx, req.(*AuthUnlockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Keys_AuthLock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AuthLockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeysServer).AuthLock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/keys.Keys/AuthLock",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeysServer).AuthLock(ctx, req.(*AuthLockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Keys_AuthReset_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AuthResetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeysServer).AuthReset(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/keys.Keys/AuthReset",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeysServer).AuthReset(ctx, req.(*AuthResetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Keys_AuthRecover_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AuthRecoverRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeysServer).AuthRecover(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/keys.Keys/AuthRecover",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeysServer).AuthRecover(ctx, req.(*AuthRecoverRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Keys_RuntimeStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RuntimeStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeysServer).RuntimeStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/keys.Keys/RuntimeStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeysServer).RuntimeStatus(ctx, req.(*RuntimeStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Keys_Rand_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RandRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeysServer).Rand(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/keys.Keys/Rand",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeysServer).Rand(ctx, req.(*RandRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Keys_RandPassword_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RandPasswordRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeysServer).RandPassword(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/keys.Keys/RandPassword",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeysServer).RandPassword(ctx, req.(*RandPasswordRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Keys_AuthProvision_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AuthProvisionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeysServer).AuthProvision(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/keys.Keys/AuthProvision",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeysServer).AuthProvision(ctx, req.(*AuthProvisionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Keys_AuthDeprovision_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AuthDeprovisionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeysServer).AuthDeprovision(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/keys.Keys/AuthDeprovision",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeysServer).AuthDeprovision(ctx, req.(*AuthDeprovisionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Keys_AuthProvisions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AuthProvisionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeysServer).AuthProvisions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/keys.Keys/AuthProvisions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeysServer).AuthProvisions(ctx, req.(*AuthProvisionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Keys_AuthPasswordChange_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AuthPasswordChangeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeysServer).AuthPasswordChange(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/keys.Keys/AuthPasswordChange",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeysServer).AuthPasswordChange(ctx, req.(*AuthPasswordChangeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Keys_VaultAuth_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VaultAuthRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeysServer).VaultAuth(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/keys.Keys/VaultAuth",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeysServer).VaultAuth(ctx, req.(*VaultAuthRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Keys_VaultSync_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VaultSyncRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeysServer).VaultSync(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/keys.Keys/VaultSync",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeysServer).VaultSync(ctx, req.(*VaultSyncRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Keys_VaultUnsync_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VaultUnsyncRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeysServer).VaultUnsync(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/keys.Keys/VaultUnsync",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeysServer).VaultUnsync(ctx, req.(*VaultUnsyncRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Keys_VaultStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VaultStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeysServer).VaultStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/keys.Keys/VaultStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeysServer).VaultStatus(ctx, req.(*VaultStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Keys_VaultUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VaultUpdateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeysServer).VaultUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/keys.Keys/VaultUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeysServer).VaultUpdate(ctx, req.(*VaultUpdateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Keys_Collections_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CollectionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeysServer).Collections(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/keys.Keys/Collections",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeysServer).Collections(ctx, req.(*CollectionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Keys_Documents_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DocumentsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeysServer).Documents(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/keys.Keys/Documents",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeysServer).Documents(ctx, req.(*DocumentsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Keys_DocumentDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DocumentDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeysServer).DocumentDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/keys.Keys/DocumentDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeysServer).DocumentDelete(ctx, req.(*DocumentDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Keys_ConfigGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConfigGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeysServer).ConfigGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/keys.Keys/ConfigGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeysServer).ConfigGet(ctx, req.(*ConfigGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Keys_ConfigSet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConfigSetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeysServer).ConfigSet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/keys.Keys/ConfigSet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeysServer).ConfigSet(ctx, req.(*ConfigSetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Keys_AdminSignURL_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AdminSignURLRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeysServer).AdminSignURL(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/keys.Keys/AdminSignURL",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeysServer).AdminSignURL(ctx, req.(*AdminSignURLRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Keys_AdminCheck_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AdminCheckRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeysServer).AdminCheck(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/keys.Keys/AdminCheck",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeysServer).AdminCheck(ctx, req.(*AdminCheckRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Keys_Channels_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChannelsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeysServer).Channels(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/keys.Keys/Channels",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeysServer).Channels(ctx, req.(*ChannelsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Keys_ChannelCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChannelCreateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeysServer).ChannelCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/keys.Keys/ChannelCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeysServer).ChannelCreate(ctx, req.(*ChannelCreateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Keys_ChannelUsers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChannelUsersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeysServer).ChannelUsers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/keys.Keys/ChannelUsers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeysServer).ChannelUsers(ctx, req.(*ChannelUsersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Keys_ChannelInvitesCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChannelInvitesCreateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeysServer).ChannelInvitesCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/keys.Keys/ChannelInvitesCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeysServer).ChannelInvitesCreate(ctx, req.(*ChannelInvitesCreateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Keys_ChannelUninvite_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChannelUninviteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeysServer).ChannelUninvite(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/keys.Keys/ChannelUninvite",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeysServer).ChannelUninvite(ctx, req.(*ChannelUninviteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Keys_ChannelInvites_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChannelInvitesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeysServer).ChannelInvites(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/keys.Keys/ChannelInvites",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeysServer).ChannelInvites(ctx, req.(*ChannelInvitesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Keys_ChannelUserInvites_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChannelUserInvitesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeysServer).ChannelUserInvites(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/keys.Keys/ChannelUserInvites",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeysServer).ChannelUserInvites(ctx, req.(*ChannelUserInvitesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Keys_ChannelJoin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChannelJoinRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeysServer).ChannelJoin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/keys.Keys/ChannelJoin",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeysServer).ChannelJoin(ctx, req.(*ChannelJoinRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Keys_ChannelLeave_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChannelLeaveRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeysServer).ChannelLeave(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/keys.Keys/ChannelLeave",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeysServer).ChannelLeave(ctx, req.(*ChannelLeaveRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Keys_MessagePrepare_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MessagePrepareRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeysServer).MessagePrepare(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/keys.Keys/MessagePrepare",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeysServer).MessagePrepare(ctx, req.(*MessagePrepareRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Keys_MessageCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MessageCreateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeysServer).MessageCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/keys.Keys/MessageCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeysServer).MessageCreate(ctx, req.(*MessageCreateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Keys_Messages_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MessagesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KeysServer).Messages(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/keys.Keys/Messages",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KeysServer).Messages(ctx, req.(*MessagesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Keys_Relay_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(RelayRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(KeysServer).Relay(m, &keysRelayServer{stream})
}

type Keys_RelayServer interface {
	Send(*RelayOutput) error
	grpc.ServerStream
}

type keysRelayServer struct {
	grpc.ServerStream
}

func (x *keysRelayServer) Send(m *RelayOutput) error {
	return x.ServerStream.SendMsg(m)
}

var _Keys_serviceDesc = grpc.ServiceDesc{
	ServiceName: "keys.Keys",
	HandlerType: (*KeysServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "KeyGenerate",
			Handler:    _Keys_KeyGenerate_Handler,
		},
		{
			MethodName: "Keys",
			Handler:    _Keys_Keys_Handler,
		},
		{
			MethodName: "Key",
			Handler:    _Keys_Key_Handler,
		},
		{
			MethodName: "KeyImport",
			Handler:    _Keys_KeyImport_Handler,
		},
		{
			MethodName: "KeyExport",
			Handler:    _Keys_KeyExport_Handler,
		},
		{
			MethodName: "KeyRemove",
			Handler:    _Keys_KeyRemove_Handler,
		},
		{
			MethodName: "Sign",
			Handler:    _Keys_Sign_Handler,
		},
		{
			MethodName: "Verify",
			Handler:    _Keys_Verify_Handler,
		},
		{
			MethodName: "VerifyDetached",
			Handler:    _Keys_VerifyDetached_Handler,
		},
		{
			MethodName: "Encrypt",
			Handler:    _Keys_Encrypt_Handler,
		},
		{
			MethodName: "Decrypt",
			Handler:    _Keys_Decrypt_Handler,
		},
		{
			MethodName: "Sigchain",
			Handler:    _Keys_Sigchain_Handler,
		},
		{
			MethodName: "Statement",
			Handler:    _Keys_Statement_Handler,
		},
		{
			MethodName: "StatementCreate",
			Handler:    _Keys_StatementCreate_Handler,
		},
		{
			MethodName: "StatementRevoke",
			Handler:    _Keys_StatementRevoke_Handler,
		},
		{
			MethodName: "User",
			Handler:    _Keys_User_Handler,
		},
		{
			MethodName: "UserSearch",
			Handler:    _Keys_UserSearch_Handler,
		},
		{
			MethodName: "UserService",
			Handler:    _Keys_UserService_Handler,
		},
		{
			MethodName: "UserSign",
			Handler:    _Keys_UserSign_Handler,
		},
		{
			MethodName: "UserAdd",
			Handler:    _Keys_UserAdd_Handler,
		},
		{
			MethodName: "Search",
			Handler:    _Keys_Search_Handler,
		},
		{
			MethodName: "Secret",
			Handler:    _Keys_Secret_Handler,
		},
		{
			MethodName: "SecretSave",
			Handler:    _Keys_SecretSave_Handler,
		},
		{
			MethodName: "SecretRemove",
			Handler:    _Keys_SecretRemove_Handler,
		},
		{
			MethodName: "Secrets",
			Handler:    _Keys_Secrets_Handler,
		},
		{
			MethodName: "Pull",
			Handler:    _Keys_Pull_Handler,
		},
		{
			MethodName: "Push",
			Handler:    _Keys_Push_Handler,
		},
		{
			MethodName: "AuthSetup",
			Handler:    _Keys_AuthSetup_Handler,
		},
		{
			MethodName: "AuthVault",
			Handler:    _Keys_AuthVault_Handler,
		},
		{
			MethodName: "AuthUnlock",
			Handler:    _Keys_AuthUnlock_Handler,
		},
		{
			MethodName: "AuthLock",
			Handler:    _Keys_AuthLock_Handler,
		},
		{
			MethodName: "AuthReset",
			Handler:    _Keys_AuthReset_Handler,
		},
		{
			MethodName: "AuthRecover",
			Handler:    _Keys_AuthRecover_Handler,
		},
		{
			MethodName: "RuntimeStatus",
			Handler:    _Keys_RuntimeStatus_Handler,
		},
		{
			MethodName: "Rand",
			Handler:    _Keys_Rand_Handler,
		},
		{
			MethodName: "RandPassword",
			Handler:    _Keys_RandPassword_Handler,
		},
		{
			MethodName: "AuthProvision",
			Handler:    _Keys_AuthProvision_Handler,
		},
		{
			MethodName: "AuthDeprovision",
			Handler:    _Keys_AuthDeprovision_Handler,
		},
		{
			MethodName: "AuthProvisions",
			Handler:    _Keys_AuthProvisions_Handler,
		},
		{
			MethodName: "AuthPasswordChange",
			Handler:    _Keys_AuthPasswordChange_Handler,
		},
		{
			MethodName: "VaultAuth",
			Handler:    _Keys_VaultAuth_Handler,
		},
		{
			MethodName: "VaultSync",
			Handler:    _Keys_VaultSync_Handler,
		},
		{
			MethodName: "VaultUnsync",
			Handler:    _Keys_VaultUnsync_Handler,
		},
		{
			MethodName: "VaultStatus",
			Handler:    _Keys_VaultStatus_Handler,
		},
		{
			MethodName: "VaultUpdate",
			Handler:    _Keys_VaultUpdate_Handler,
		},
		{
			MethodName: "Collections",
			Handler:    _Keys_Collections_Handler,
		},
		{
			MethodName: "Documents",
			Handler:    _Keys_Documents_Handler,
		},
		{
			MethodName: "DocumentDelete",
			Handler:    _Keys_DocumentDelete_Handler,
		},
		{
			MethodName: "ConfigGet",
			Handler:    _Keys_ConfigGet_Handler,
		},
		{
			MethodName: "ConfigSet",
			Handler:    _Keys_ConfigSet_Handler,
		},
		{
			MethodName: "AdminSignURL",
			Handler:    _Keys_AdminSignURL_Handler,
		},
		{
			MethodName: "AdminCheck",
			Handler:    _Keys_AdminCheck_Handler,
		},
		{
			MethodName: "Channels",
			Handler:    _Keys_Channels_Handler,
		},
		{
			MethodName: "ChannelCreate",
			Handler:    _Keys_ChannelCreate_Handler,
		},
		{
			MethodName: "ChannelUsers",
			Handler:    _Keys_ChannelUsers_Handler,
		},
		{
			MethodName: "ChannelInvitesCreate",
			Handler:    _Keys_ChannelInvitesCreate_Handler,
		},
		{
			MethodName: "ChannelUninvite",
			Handler:    _Keys_ChannelUninvite_Handler,
		},
		{
			MethodName: "ChannelInvites",
			Handler:    _Keys_ChannelInvites_Handler,
		},
		{
			MethodName: "ChannelUserInvites",
			Handler:    _Keys_ChannelUserInvites_Handler,
		},
		{
			MethodName: "ChannelJoin",
			Handler:    _Keys_ChannelJoin_Handler,
		},
		{
			MethodName: "ChannelLeave",
			Handler:    _Keys_ChannelLeave_Handler,
		},
		{
			MethodName: "MessagePrepare",
			Handler:    _Keys_MessagePrepare_Handler,
		},
		{
			MethodName: "MessageCreate",
			Handler:    _Keys_MessageCreate_Handler,
		},
		{
			MethodName: "Messages",
			Handler:    _Keys_Messages_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SignFile",
			Handler:       _Keys_SignFile_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "SignStream",
			Handler:       _Keys_SignStream_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "VerifyFile",
			Handler:       _Keys_VerifyFile_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "VerifyStream",
			Handler:       _Keys_VerifyStream_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "VerifyDetachedFile",
			Handler:       _Keys_VerifyDetachedFile_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "VerifyDetachedStream",
			Handler:       _Keys_VerifyDetachedStream_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "EncryptStream",
			Handler:       _Keys_EncryptStream_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "EncryptFile",
			Handler:       _Keys_EncryptFile_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "DecryptStream",
			Handler:       _Keys_DecryptStream_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "DecryptFile",
			Handler:       _Keys_DecryptFile_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "Wormhole",
			Handler:       _Keys_Wormhole_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "Relay",
			Handler:       _Keys_Relay_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "keys.proto",
}
